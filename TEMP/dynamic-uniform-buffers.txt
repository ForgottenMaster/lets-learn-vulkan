1. Create ability to render multiple meshes with different vertex buffer/index buffer to illustrate problem.
-------------------------------------------------------------------------------------------
struct Mesh {
    vertex_buffer: Buffer,
    vertex_buffer_memory: DeviceMemory,
    index_buffer: Buffer,
    index_buffer_memory: DeviceMemory,
    index_count: usize
}
-------------------------------------------------------------------------------------------
        let meshes = vec![
            create_mesh(
                &instance,
                &logical_device,
                physical_device,
                graphics_command_pool,
                queues.graphics_queue,
                &[
                    Vertex {
                        position: [-0.6, -0.2, 0.0],
                        color: [1.0, 0.0, 0.0],
                    },
                    Vertex {
                        position: [-0.2, 0.2, 0.0],
                        color: [0.0, 1.0, 0.0],
                    },
                    Vertex {
                        position: [-0.6, 0.2, 0.0],
                        color: [0.0, 0.0, 1.0],
                    },
                    Vertex {
                        position: [-0.2, -0.2, 0.0],
                        color: [1.0, 1.0, 0.0],
                    },
                ],
                &[0, 1, 2, 1, 0, 3],
            )?,
            create_mesh(
                &instance,
                &logical_device,
                physical_device,
                graphics_command_pool,
                queues.graphics_queue,
                &[
                    Vertex {
                        position: [0.2, -0.2, 0.0],
                        color: [1.0, 0.0, 0.0],
                    },
                    Vertex {
                        position: [0.6, 0.2, 0.0],
                        color: [0.0, 1.0, 0.0],
                    },
                    Vertex {
                        position: [0.2, 0.2, 0.0],
                        color: [0.0, 0.0, 1.0],
                    },
                    Vertex {
                        position: [0.6, -0.2, 0.0],
                        color: [1.0, 1.0, 0.0],
                    },
                ],
                &[0, 1, 2, 1, 0, 3],
            )?,
        ];
-------------------------------------------------------------------------------------------
fn create_mesh(
    instance: &Instance,
    device: &Device,
    physical_device: PhysicalDevice,
    transfer_command_pool: CommandPool,
    transfer_queue: Queue,
    vertex_buffer_data: &[Vertex],
    index_buffer_data: &[u16],
) -> Result<Mesh> {
    let (vertex_buffer, vertex_buffer_memory) = create_vertex_buffer(
        instance,
        device,
        physical_device,
        vertex_buffer_data,
        transfer_command_pool,
        transfer_queue,
    )
    .context("Error while trying to create vertex buffer for a mesh.")?;
    let (index_buffer, index_buffer_memory) = create_index_buffer(
        instance,
        device,
        physical_device,
        index_buffer_data,
        transfer_command_pool,
        transfer_queue,
    )
    .context("Error while trying to create index buffer for a mesh.")?;
    Ok(Mesh {
        vertex_buffer,
        vertex_buffer_memory,
        index_buffer,
        index_buffer_memory,
        index_count: index_buffer_data.len()
    })
}
-------------------------------------------------------------------------------------------
            for mesh in meshes {
                device.cmd_bind_vertex_buffers(*command_buffer, 0, &[mesh.vertex_buffer], &[0]);
                device.cmd_bind_index_buffer(
                    *command_buffer,
                    mesh.index_buffer,
                    0,
                    IndexType::UINT16,
                );
                device.cmd_draw_indexed(
                    *command_buffer,
                    mesh.index_count.try_into().unwrap(),
                    1,
                    0,
                    0,
                    0,
                );
            }
-------------------------------------------------------------------------------------------
        for mesh in meshes {
            device.free_memory(mesh.index_buffer_memory, None);
            device.destroy_buffer(mesh.index_buffer, None);
            device.free_memory(mesh.vertex_buffer_memory, None);
            device.destroy_buffer(mesh.vertex_buffer, None);
        }













-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
2. Explain how dynamic uniform buffers are used for per-mesh data.
    - Show the gif of why it's needed
    - Show an image of buffer layout in dynamic uniform buffers













-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
3. Remove Model data temporarily from the project and just keep ViewProjection data.
-------------------------------------------------------------------------------------------
#[repr(C)]
struct UboViewProjection {
    projection: Mat4,
    view: Mat4,
}
-------------------------------------------------------------------------------------------
layout(binding = 0) uniform UboViewProjection {
    mat4 projection;
    mat4 view;
} vp;
-------------------------------------------------------------------------------------------
gl_Position = vp.projection * vp.view * mat4(1.0) * vec4(position, 1.0);












-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
4. Create a uniform buffer object (UboModel) for the per model data that'll be stored in the dynamic buffer.

#[repr(C)]
struct UboModel(Mat4);






-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
5. Update vertex shader to split the UboModel out from projection and view.
	- Needs binding 1 since the buffer is bound differently

layout(binding = 1) uniform UboModel {
    mat4 model;
} m;

gl_Position = vp.projection * vp.view * m.model * vec4(position, 1.0);









-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
6. Allocate aligned memory for X UboModels with minimum alignment of minUniformBufferOffset.
	- Can use the Layout type to allocate correctly aligned memory.
	- Use Layout::repeat but will have to write own version on stable Rust.
	- Allocate for a maximum number.
	- Remember to free allocated memory (dealloc in Rust).
-------------------------------------------------------------------------------------------
fn create_model_uniform_buffers(
    instance: &Instance,
    device: &Device,
    physical_device: PhysicalDevice,
    count: usize,
    max_models: u64,
    model_stride: u64,
) -> Result<Vec<(Buffer, DeviceMemory)>> {
    let mut buffers = Vec::with_capacity(count);
    for _ in 0..count {
        buffers.push(
            create_buffer(
                instance,
                device,
                physical_device,
                BufferUsageFlags::UNIFORM_BUFFER,
                MemoryPropertyFlags::HOST_VISIBLE | MemoryPropertyFlags::HOST_COHERENT,
                max_models * model_stride,
            )
            .context("Failed to create a uniform buffer.")?,
        );
    }
    Ok(buffers)
}
-------------------------------------------------------------------------------------------
const MAX_MODELS: u64 = 2;
let physical_device_properties =
    unsafe { instance.get_physical_device_properties(physical_device) };
let minimum_uniform_buffer_offset_alignment = physical_device_properties
    .limits
    .min_uniform_buffer_offset_alignment;
let ubo_model_aligned_size = Layout::new::<UboModel>()
    .align_to(minimum_uniform_buffer_offset_alignment as usize)
    .context("Could not pad UboModel to minimum offset alignment.")?
    .pad_to_align()
    .size();
let model_uniform_buffers = create_model_uniform_buffers(
    &instance,
    &logical_device,
    physical_device,
    swapchain_images.len(),
    MAX_MODELS,
    ubo_model_aligned_size as u64,
)?;
-------------------------------------------------------------------------------------------











-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
7. Create a second binding in the descriptor set layout
	- Binding number is 1.
	- Descriptor type is uniform buffer dynamic.








-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
8. Create second uniform buffer for the dynamic ubo buffer.







-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
9. Descriptor pool needs changing to add a new pool size.
	- Pool size type needs to be uniform buffer dynamic.
	- Change max sets to swap chain images size.






-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
10. Update creation of descriptor sets to include the creation of the model dynamic buffers.
	- Range is size of a single piece of data.
	- Descriptor type is uniform buffer dynamic.









-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
11. Update recording of commands/command buffer.
	- When we're looping through meshes and binding index/vertex buffers, dynamic offset is the size of a single one multiplied by the mesh index.
	- Actually pass dynamic offset through to the vkCmdBindDescriptorSets call.






-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
12. Change function that updates uniform buffers for a given image index.
	- View projection buffer is updated the same way because it's global for the whole draw call.
	- For model buffer, should copy data to the aligned memory transfer space allocation.
	- Write the model data to the correct location in memory.
	- Can then copy the whole transfer space over to buffer memory.










-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
13. Add a mesh-specific rotation to show only one mesh rotating.