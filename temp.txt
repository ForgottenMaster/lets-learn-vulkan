fn create_image(
    instance: &Instance,
    device: &Device,
    physical_device: PhysicalDevice,
    width: u32,
    height: u32,
    tiling: ImageTiling,
    usage: ImageUsageFlags,
    initial_layout: ImageLayout,
    format: Format,
    flags: MemoryPropertyFlags,
) -> Result<(Image, DeviceMemory)> {
    unsafe {
        let image = device
            .create_image(
                &ImageCreateInfo::builder()
                    .image_type(ImageType::TYPE_2D)
                    .format(format)
                    .extent(
                        Extent3D::builder()
                            .width(width)
                            .height(height)
                            .depth(1)
                            .build(),
                    )
                    .mip_levels(1)
                    .array_layers(1)
                    .samples(SampleCountFlags::TYPE_1)
                    .tiling(tiling)
                    .usage(usage)
                    .initial_layout(initial_layout)
                    .sharing_mode(SharingMode::EXCLUSIVE),
                None,
            )
            .context("Failed to create image.")?;
        let memory_requirements = device.get_image_memory_requirements(image);
        let memory_properties = instance.get_physical_device_memory_properties(physical_device);
        let memory_index =
            find_valid_memory_type_index(memory_properties, memory_requirements, flags)
                .ok_or_else(|| anyhow!("Failed to find a valid memory index for image."))?;
        let memory = device
            .allocate_memory(
                &MemoryAllocateInfo::builder()
                    .allocation_size(memory_requirements.size)
                    .memory_type_index(memory_index as u32),
                None,
            )
            .context("Failed to allocate device memory for image.")?;
        device
            .bind_image_memory(image, memory, 0)
            .context("Failed to bind image memory.")?;
        Ok((image, memory))
    }
}

===========================================================================================================

fn create_depth_buffer_image(
    instance: &Instance,
    device: &Device,
    physical_device: PhysicalDevice,
    width: u32,
    height: u32,
    tiling: ImageTiling,
) -> Result<(Image, DeviceMemory)> {
    let format = get_best_image_format(
        instance,
        physical_device,
        &[
            Format::D32_SFLOAT_S8_UINT,
            Format::D32_SFLOAT,
            Format::D24_UNORM_S8_UINT,
        ],
        tiling,
        FormatFeatureFlags::DEPTH_STENCIL_ATTACHMENT,
    )
    .ok_or_else(|| anyhow!("Failed to get a valid image format."))?;
    create_image(
        instance,
        device,
        physical_device,
        width,
        height,
        tiling,
        ImageUsageFlags::DEPTH_STENCIL_ATTACHMENT,
        ImageLayout::UNDEFINED,
        format,
        MemoryPropertyFlags::DEVICE_LOCAL,
    )
    .context("Failed to create depth buffer image")
}

===========================================================================================================

fn get_best_image_format(
    instance: &Instance,
    physical_device: PhysicalDevice,
    formats: &[Format],
    tiling: ImageTiling,
    flags: FormatFeatureFlags,
) -> Option<Format> {
    formats.iter().copied().find(|format| {
        let properties =
            unsafe { instance.get_physical_device_format_properties(physical_device, *format) };
        match tiling {
            ImageTiling::OPTIMAL => properties.optimal_tiling_features.contains(flags),
            ImageTiling::LINEAR => properties.linear_tiling_features.contains(flags),
            _ => false,
        }
    })
}

================================================================================================

let (depth_buffer_image, depth_buffer_image_memory) = create_depth_buffer_image(
            &instance,
            &logical_device,
            physical_device,
            swapchain_extent.width,
            swapchain_extent.height,
            ImageTiling::OPTIMAL,
        )
        .context("Failed to create depth buffer.")?;

================================================================================================

Issue with backing surface disappearing as window is closed - segfault if destroying swapchain on cleanup. Use:

Event::LoopDestroyed => unsafe { swapchain_ext.destroy_swapchain(swapchain, None) },

================================================================================================

Also pass tiling and feature flags when choosing supported format
Check tiling type and compare features against supported for that tiling type
Add depth attachment to render pass
Add depth attachment to framebuffer
Add a depth stencil state to pipeline
Clear values for depth attachment is just 1
